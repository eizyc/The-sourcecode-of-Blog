title: åˆ·é¢˜ç”¨çš„æ•°æ®ç»“æ„
tags: []
categories: []
date: 2019-07-09 20:10:00
author:
---
#### åˆ·é¢˜ç”¨çš„æ•°æ®ç»“æ„
+ æ•°æ®ç»“æ„
	1. å¹¶æŸ¥é›†ï¼ˆUnion-find setsï¼‰
     + [åŸºäºsizeè¡¨ç¤ºèŠ‚ç‚¹ä¸ªæ•°çš„ä¼˜åŒ–çš„å¹¶æŸ¥é›†](#1)
 	  + [åŸºäºrankè¡¨ç¤ºæ ¹èŠ‚ç‚¹ä¸ºiçš„æ ‘ä¼˜åŒ–çš„å¹¶æŸ¥é›†](#2)
 	  + [å¸¦è·¯å¾„ä¼˜åŒ–çš„å¹¶æŸ¥é›†](#3)
	2. å †å’Œä¼˜å…ˆé˜Ÿåˆ—
	3. äºŒåˆ†æœç´¢æ ‘  
	4. å­—å…¸æ ‘/å‰ç¼€æ ‘ï¼ˆTrieï¼‰
	5. çº¿æ®µæ ‘/åŒºé—´æ ‘ï¼ˆSegement Treeï¼‰
	6. AVLï¼ˆä¸€ç§å…¸å‹çš„å¹³è¡¡äºŒå‰æ ‘ï¼‰
	7. çº¢é»‘æ ‘
<!--more--> 

åŸºäºsizeè¡¨ç¤ºèŠ‚ç‚¹ä¸ªæ•°çš„ä¼˜åŒ–çš„å¹¶æŸ¥é›†ğŸ‘‡ğŸ½<span id="1"> </span>
```c++
#include<bits/stdc++.h>
using namespace std;

class UnionFind
{
private:
    int* parent;
    int* size;//size[i]è¡¨ç¤ºä»¥iä¸ºæ ¹çš„é›†åˆä¸­å…ƒç´ ä¸ªæ•°
    int count;

public:
    UnionFind(int count)
    {
        parent = new int[count];
        rank = new int [count];
        this->count=count;
        for(int i=0; i<count; i++)
        {
            parent[i]=i;
            size[i]=1;
        }
    }
    ~UnionFind()
    {
        delete[] parent;
        delete[] size;
    }
    int size()
    {
        return count;
    }
    bool isConnected(int p, int q)
    {
        return find(p) == find(q);
    }
    int find(int p)
    {
        assert(p >= 0 && p < count);
        while(p!=parent[p])//ä¸ç”¨æ‹…å¿ƒçˆ¶äº²çš„çˆ¶äº²æ²¡æœ‰èŠ‚ç‚¹ï¼Œå› ä¸ºçˆ¶äº²çš„èŠ‚ç‚¹æŒ‡å‘è‡ªå·±
        {
            p = parent[p];
        }
        return p;
    }

    void unionElements(int p,int q)
    {
        int pRoot = find(p);
        int qRoot = find(q);

        if( pRoot == qRoot )
            return;

        if( size[qRoot] < size[pRoot] )
        {
            parent[pRoot] = qRoot;
            size[qRoot] +=size[pRoot]
        }
        else
        {
            parent[qRoot] = pRoot;
            size[pRoot] +=size[qRoot]
        }
    }
};
int main()
{
    return 0;
}
```
åŸºäºrankè¡¨ç¤ºæ ¹èŠ‚ç‚¹ä¸ºiçš„æ ‘ä¼˜åŒ–çš„å¹¶æŸ¥é›†ğŸ‘‡ğŸ½<span id="2"> </span>
```c++
#include<bits/stdc++.h>
using namespace std;

class UnionFind
{
private:
    int* parent;
    int* rank;//rank[i]è¡¨ç¤ºä»¥iä¸ºæ ¹çš„é›†åˆæ‰€è¡¨ç¤ºçš„æ ‘çš„å±‚æ•°
    int count;

public:
    UnionFind(int count)
    {
        parent = new int[count];
        rank = new int [count];
        this->count=count;
        for(int i=0; i<count; i++)
        {
            parent[i]=i;
            rank[i]=1;
        }
    }
    ~UnionFind()
    {
        delete[] parent;
        delete[] rank;
    }
    int size()
    {
        return count;
    }
    bool isConnected(int p, int q)
    {
        return find(p) == find(q);
    }
    int find(int p)
    {
        assert(p >= 0 && p < count);
        while(p!=parent[p])//ä¸ç”¨æ‹…å¿ƒçˆ¶äº²çš„çˆ¶äº²æ²¡æœ‰èŠ‚ç‚¹ï¼Œå› ä¸ºçˆ¶äº²çš„èŠ‚ç‚¹æŒ‡å‘è‡ªå·±
        {
            p = parent[p];
        }
        return p;
    }

    void unionElements(int p,int q)
    {
        int pRoot = find(p);
        int qRoot = find(q);

        if( pRoot == qRoot )
            return;

        if( rank[qRoot] < rank[pRoot] )
        {
            parent[pRoot] = qRoot;
        }
        else if(rank[qRoot] > rank[pRoot])
        {
            parent[qRoot] = pRoot;
        }
        else
        {
            parent[pRoot] = qRoot;
            rank[qRoot] += 1;
        }
    }
};
int main()
{
    return 0;
}

```
å¸¦è·¯å¾„ä¼˜åŒ–çš„å¹¶æŸ¥é›†ğŸ‘‡ğŸ½<span id="3"> </span>
```c++
#include<bits/stdc++.h>
using namespace std;

class UnionFind
{
private:
    int* parent;
    int* rank;//rank[i]è¡¨ç¤ºä»¥iä¸ºæ ¹çš„é›†åˆæ‰€è¡¨ç¤ºçš„æ ‘çš„å±‚æ•°
    int count;

public:
    UnionFind(int count)
    {
        parent = new int[count];
        rank = new int [count];
        this->count=count;
        for(int i=0; i<count; i++)
        {
            parent[i]=i;
            rank[i]=1;
        }
    }
    ~UnionFind()
    {
        delete[] parent;
        delete[] rank;
    }
    int size()
    {
        return count;
    }
    bool isConnected(int p, int q)
    {
        return find(p) == find(q);
    }
    int find(int p)
    {
        assert(p >= 0 && p < count);
        while(p!=parent[p])//ä¸ç”¨æ‹…å¿ƒçˆ¶äº²çš„çˆ¶äº²æ²¡æœ‰èŠ‚ç‚¹ï¼Œå› ä¸ºçˆ¶äº²çš„èŠ‚ç‚¹æŒ‡å‘è‡ªå·±
        {
            parent[p] = parent[parent[p]];//è¿™é‡Œåšäº†è·¯å¾„ä¼˜åŒ–ï¼Œè·³äº†ä¸€ä¸ªçˆ¶å…ƒç´ ï¼Œå°±å·®äº†è¿™ä¸€è¡Œï¼Œä¸ä¸Šä¸€ä¸ªç›¸æ¯”
            p = parent[p];
        }
        return p;
    }

    void unionElements(int p,int q)
    {
        int pRoot = find(p);
        int qRoot = find(q);

        if( pRoot == qRoot )
            return;

        if( rank[qRoot] < rank[pRoot] )
        {
            parent[pRoot] = qRoot;
        }
        else if(rank[qRoot] > rank[pRoot])
        {
            parent[qRoot] = pRoot;
        }
        else
        {
            parent[pRoot] = qRoot;
            rank[qRoot] += 1;
        }
    }
};
int main()
{
    return 0;
}

```